//------------------------------------------------------------------------------
#pragma once
//------------------------------------------------------------------------------

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "Classes/Utils.h"

//==============================================================================

/**
 * @brief Класс описывает структуру данных типа стек (очередь LIFO).
 * Выделение памяти для хранилища выполняется динамически в куче однократно
 * при создании объекта (см. количество элементов по-умолчанию в конструкторе).
 * 
 * @tparam T - тип элемента (item'а).
 */
template <typename T>
class ClassStackStatic
{
protected:
	uint8_t nItemsMax;	// Максимальное количество элементов в стеке.
	uint8_t iEnd;		// По этому индексу помещаются новые элементы.
	T * pData;			// Указатель на хранилище (на массив элементов).
	//--------------------------------------------------------------------------
public:
	/**
	 * @brief Construct a new Class Stack Static object
	 * 
	 * @param ArgNItemsMax - макс. количество элементов в стеке. По-умолчанию - 5.
	 */
	ClassStackStatic( uint8_t ArgNItemsMax = 5 )
	{
		ASSERT_CUSTOM( 0, ArgNItemsMax != 0 );
		nItemsMax = ArgNItemsMax;
		pData = utils::AssertPtr(0, new T[ArgNItemsMax]);

		Clear();
	}
	//--------------------------------------------------------------------------
public:
	/**
	 * @brief Помещает элемент на вершину стека (в конец очереди).
	 * При переполнении вызывается ASSERT_CUSTOM.
	 * Копирование из указателя в элемент буфера выполняется через операцию
	 * "равно" (присвоение).
	 *
	 * @param ArgItem - источник данных для Item'а.
	 */
	void AddToBack(const T & ArgItem)
	{
		if (iEnd >= nItemsMax)
		{ // нет места для добавления нового элемента, попытка переполнения стека! Не добавляем элемент!
			ASSERT_CUSTOM(0, false);
		}
		else
		{
			pData[iEnd] = ArgItem;
			iEnd++;
		}
	}
	//--------------------------------------------------------------------------
public:
	/**
	 * @brief Возвращает !!! Без удаления !!! последний (самый новый) элемент стека.
	 * Проверка, что стек пуст, проверяется ASSERT_CUSTOM.
	 * 
	 * @return \p const T & - ссылка на элемент.
	 */
	const T & ReadLast(void)
	{
		if (iEnd == 0)
		{ 	// критическая ошибка! стек пуст, нет элементов!!!
			ASSERT_CUSTOM(0, false);
			return pData[0]; // в случае ошибки попробуем вернуть чего-нибудь наименее критичное!
		}

		return pData[iEnd-1];
	}
	//--------------------------------------------------------------------------
public:
	/**
	 * @brief Удаление последнего элемента, если он есть.
	 * Технически изменяем только индекс, без затирания памяти.
	 */
	// TODO: планируется использовать?
	void DeleteLast(void)
	{
		if (iEnd != 0)
		{
			iEnd--;
		}
	}
	//--------------------------------------------------------------------------
public:
	/**
	 * @brief Очистка стека с удалением всех элементов. Даже если "пустой".
	 * Обнуляем индексы и хранилище, чтобы было проще отлаживаться в
	 * случаях сбоев.
	 */
	void Clear(void)
	{
		memset(pData, 0, nItemsMax * sizeof(T));

		iEnd = 0;
	}
	//--------------------------------------------------------------------------
public:
	/**
	 * @brief Возвращает количество элементов в стеке.
	 * 
	 * @return количество элементов в стеке.
	 */
	uint8_t GetCount(void)
	{
		return iEnd;
	}
	//--------------------------------------------------------------------------
};
//******************************************************************************
